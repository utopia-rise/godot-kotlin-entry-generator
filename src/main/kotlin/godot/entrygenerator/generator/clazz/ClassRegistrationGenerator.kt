package godot.entrygenerator.generator.clazz

import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.TypeSpec
import godot.entrygenerator.extension.EntryGeneratorExtension
import godot.entrygenerator.extension.getAnnotationValue
import godot.entrygenerator.extension.getSuperTypeNameAsString
import godot.entrygenerator.model.ClassWithMembers
import godot.entrygenerator.model.REGISTER_CLASS_ANNOTATION
import godot.entrygenerator.model.REGISTER_CLASS_ANNOTATION_TOOL_ARGUMENT
import org.jetbrains.kotlin.cli.common.messages.MessageCollector
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.descriptors.PropertyDescriptor
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe

abstract class ClassRegistrationGenerator {

    abstract fun provideRegisterClassControlFlow(
        classWithMembers: ClassWithMembers,
        classRegistryControlFlow: FunSpec.Builder,
        className: ClassName,
        superClass: String,
        isTool: Boolean
    ): FunSpec.Builder

    abstract fun registerFunctions(
        functions: List<FunctionDescriptor>,
        registerClassControlFlow: FunSpec.Builder,
        className: ClassName,
        extensionToDescriptors: Map<EntryGeneratorExtension, Set<ClassWithMembers>>,
        extensionHelperObjectSpec: TypeSpec.Builder?,
        messageCollector: MessageCollector
    )

    abstract fun registerSignals(
        signals: List<PropertyDescriptor>,
        registerClassControlFlow: FunSpec.Builder,
        messageCollector: MessageCollector
    )

    abstract fun registerProperties(
        properties: List<PropertyDescriptor>,
        registerClassControlFlow: FunSpec.Builder,
        className: ClassName,
        bindingContext: BindingContext,
        messageCollector: MessageCollector
    )

    fun registerClasses(
        classesWithMembers: Set<ClassWithMembers>,
        classRegistryControlFlow: FunSpec.Builder,
        bindingContext: BindingContext,
        messageCollector: MessageCollector,
        extensionToDescriptors: Map<EntryGeneratorExtension, Set<ClassWithMembers>>,
        extensionHelperObjectSpec: TypeSpec.Builder?
    ) {
        classesWithMembers.forEach { classWithMembers ->
            val classNameAsString = classWithMembers.classDescriptor.name.asString()
            val packagePath = classWithMembers.classDescriptor.fqNameSafe.parent().asString()
            val className = ClassName(packagePath, classNameAsString)
            val superClass = classWithMembers.classDescriptor.getSuperTypeNameAsString()

            val registerClassControlFlow = provideRegisterClassControlFlow(
                classWithMembers, classRegistryControlFlow, className, superClass, isTool(classWithMembers.classDescriptor)
            ) //START: registerClass

            registerFunctions(
                classWithMembers.functions,
                registerClassControlFlow,
                className,
                extensionToDescriptors,
                extensionHelperObjectSpec,
                messageCollector
            )

            registerSignals(
                classWithMembers.signals,
                registerClassControlFlow,
                messageCollector
            )

            registerProperties(
                classWithMembers.properties,
                registerClassControlFlow,
                className,
                bindingContext,
                messageCollector
            )

            extensionToDescriptors.forEach { (extension, extensionClassesWithMembers) ->
                extensionClassesWithMembers
                    .firstOrNull { it.classDescriptor == classWithMembers.classDescriptor && extension.registersElementsForClass(it, messageCollector) }
                    ?.let { extensionClassWithMembers ->
                        registerClassControlFlow.addComment("================EXTENSION BLOCK================")
                        registerClassControlFlow.addComment("START: Generated by extension: ${extension.provideExtensionName()}")
                        registerClassControlFlow.addComment("Extension entry class: ${extension::class.qualifiedName}")
                        extension.registerFunctions(
                            classWithMembers.functions,
                            extensionClassWithMembers.functions,
                            registerClassControlFlow,
                            className,
                            bindingContext,
                            messageCollector
                        )
                        extension.registerSignals(
                            classWithMembers.signals,
                            extensionClassWithMembers.signals,
                            registerClassControlFlow,
                            className,
                            bindingContext,
                            messageCollector
                        )
                        extension.registerProperties(
                            classWithMembers.properties,
                            extensionClassWithMembers.properties,
                            registerClassControlFlow,
                            className,
                            bindingContext,
                            messageCollector
                        )
                        registerClassControlFlow.addComment("END: Generated by extension: ${extension.provideExtensionName()}")
                        registerClassControlFlow.addComment("Extension entry class: ${extension::class.qualifiedName}")
                        registerClassControlFlow.addComment("================EXTENSION BLOCK================")
                    }
            }

            registerClassControlFlow.endControlFlow() //END: registerClass
        }
    }

    private fun isTool(classDescriptor: ClassDescriptor): Boolean {
        return classDescriptor
            .annotations
            .getAnnotationValue(REGISTER_CLASS_ANNOTATION, REGISTER_CLASS_ANNOTATION_TOOL_ARGUMENT, false)
    }
}
